# 设计模式 C#

> 原文:[https://www.javatpoint.com/design-patterns-c-sharp](https://www.javatpoint.com/design-patterns-c-sharp)

在本文中，我们将讨论 C#中使用不同子类的各种设计模式。我们将从零开始获得绝对的知识，以及不同类型的设计模式如何在解决各种问题中发挥不同的作用。我们开始吧。

## 什么是设计模式？

我们经常被一些找不到出路的具体问题的漏洞所困。我们也没有意识到到底什么能让一段示例代码在速度和敏捷性方面更高效。这些问题在用 C#开发应用程序时非常普遍，因为它们具有动态和复杂的特性。这就是设计模式在确定解决这类问题的差距和机会方面发挥主要作用的地方。

然而，设计模式是**通用解决方案提供商**，或者他们可以被称为**灵活解决方案**制造商，用于解决常见的设计模式问题。在面向对象编程的世界中，它是可重用解决方案的提供者，通常在应用程序开发中定期出现。设计模式为如何解决多种情况下出现的问题提供了模板或描述方法。

## 设计模式的重要性

[C#](https://www.javatpoint.com/c-sharp-tutorial) 或任何其他核心编程语言中的每个设计模式都描绘了一个在特定环境中反复出现的特殊问题，以及这些问题的解决方案，即识别**敏捷性、简单性、**和**复杂性**以生成一个最佳解决方案，仅用一个解决方案就解决了数百万个问题，这就是设计模式存在的目的。准确地说，它是所有这些问题的模式语言。

具体来说，在 C#中选择某种模式并不局限于只解决一个问题。模式非常高效，只需几行代码就能解决数百万个问题。此外，选择设计模式的方法取决于问题的唯一性质以及个人需求。此外，几乎所有的开发人员都非常了解设计模式。他们知道这个工具有多强大。因此，理解设计模式不能通过记忆属性、方法和类来混淆是非常重要的，更重要的是开发一种健康的方法来实现这些模式的无效使用，以获得期望的结果。实现针对某类问题的特定方法也很重要，持续的实践将涉及解决最适合的设计。

C#中虽然有大量的设计模式大约 **23** 也就是**四人帮。**既然我们已经理解了这些模式有多重要，让我们以绝对结构化的方式继续发现这些模式。考虑以下图像:

![Design Patterns C#](../Images/66fc54c7cc22022c5349216880cc6bdd.png)

## 创新设计模式

创造性设计模式提供了一个有效的**和**动态的**动力机制，引导代码可重用性的接近，并增强灵活性，以便在更广阔的领域解决问题。竞技场越宽，就越容易被发现和解决。创造性的设计模式包含了下面有趣讨论的各种子类别。**

**![Design Patterns C#](../Images/bb873eca56b6aa8204d5e99fd9d7702d.png)

**工厂**方法主要用于在子类中提供创建对象，并且允许这些子类改变将要创建的对象的类型。

![Design Patterns C#](../Images/10f121c1c541ef3a0ae9e1811c400e5f.png)

抽象工厂模式允许我们产生多个相关对象的族，而不需要指定它们属于哪个类。他们完全隐藏在幕后。

![Design Patterns C#](../Images/7fe1a1edec5895363ea1cecffdf35770.png)

**构建器模式**将让我们生成多个相关对象的族，而无需指定它们属于哪个类。他们完全隐藏在幕后。

![Design Patterns C#](../Images/7368255928983517964b268998e00f81.png)

原型设计模式将允许我们在实现现有对象时复制它们，而不必完全依赖于定义的类。

![Design Patterns C#](../Images/aeab391d8840a3f82f743f6e3f1ff762.png)

顾名思义，这种模式确保一个类应该只有一个实例，条件是提供对该实例的全局访问点。

## 结构设计模式

结构设计模式提供了在大型结构中构建对象和类的灵活性，因此它们可以处理在特定情况下出现的更大的问题。这种设计模式确保所有的对象和类都被组装成一个大的结构，而不会影响效率和保持灵活性。它由如下所示的各种**子类别**组成。

![Design Patterns C#](../Images/5bc4b1b09c8eaf2526668b050e191528.png)

这允许与所有被发现与基于解决方案的方法不兼容的接口进行协作。

![Design Patterns C#](../Images/383d64c91973a1844821cb7d0006c52d.png)

它允许根据层次结构将一个大类或集合分成几个小片段或密切相关的类。它可以被称为抽象实现，其中这些小类被合理地和独立地处理。

![Design Patterns C#](../Images/f0ffa8de288bee0c0f43c020cf8019fb.png)

复合结构允许我们通过以树结构的形式组合对象，分割出节点，并将它们作为单独的对象来处理，从而驱动基于解决方案的机制。

![Design Patterns C#](../Images/b2b40f2cba8dce68e9fca1afc20f5f0d.png)

装饰器能够将各种新行为附加到对象上。它通过将这些对象隐藏在特殊的包装对象中，然后在其中包含行为来实现。

![Design Patterns C#](../Images/f2b3ed7d0f71faaea0fb29b0d3cd5a97.png)

门面提供了一个简单的界面，并通过管理界面中的增强来描述有效的解决方案，从而暴露给库或框架，无论我们使用什么框架。

![Design Patterns C#](../Images/8777c87253e38c1a24f88a8063fe3185.png)

Flyweight 允许我们在内存中放入更多的对象。这是通过共享在多个对象之间找到的状态的公共部分来实现的，而不是必须存储每个对象的所有数据。

![Design Patterns C#](../Images/772a2a64e6e51743f2c52ca62c085b65.png)

它为另一个对象提供了不同的方式或替代品。它为控制原始对象访问的代理提供了一个占位符。因此，请求在原始对象被允许之前或之后被处理。

## 行为设计模式

行为设计模式严格限于战略或算法方法。这种模式主要关注的是在不同对象之间分担或放置责任的方法。如下所示，这种模式可以分为不同的子类别。

![Design Patterns C#](../Images/663fca1eeeb464614cd70a5f8beb987f.png)

它将请求传递给处理程序链。当这些处理程序在任何事件中接收到请求时，这些处理程序决定是将请求传递给链中的另一个处理程序，还是处理当前接收到的请求。

![Design Patterns C#](../Images/0c738fa43108216ff63abcd71a03855e.png)

它将请求转化为独立的对象，这些对象包含了请求的所有数据。稍后，该请求作为方法参数传递，用于处理和支持不可撤销或排队的操作。

![Design Patterns C#](../Images/1c957b57df7662cc76d025e7a04b9668.png)

这将允许您迭代有问题的模式的集合或列表，而不必公开底层表示。

![Design Patterns C#](../Images/63c93c65e548028c2bbef1c8f40fc179.png)

它只是通过停止对象之间的直接通信来减少导致混乱的依赖关系，进而迫使它们通过中介对象进行协作。

![Design Patterns C#](../Images/b67d3631a2ed078ae0d7885d119213cf.png)

它只是隐藏了对象的实现细节，并维护了保存和恢复先前状态等操作。

![Design Patterns C#](../Images/6ede0aa050a45aef9e463a8168a8527d.png)

它有助于为订阅定义一种机制，该机制最终将对象在观察时可能发生的任何事件通知给对象。

![Design Patterns C#](../Images/49e9d6095f581c29087d03cc83f658c6.png)

它允许改变整个对象状态中存在的一些内部变化的状态。它可能看起来像一个改变了类的对象。

![Design Patterns C#](../Images/66c379d2070136733b1e27b6eb8d7d6b.png)

它允许我们通过原生算法家族将对象放入不同的类来交换对象。

![Design Patterns C#](../Images/856bf3791eedf82fe1c478334f8c2525.png)

它允许在算法的某些预定义阶段覆盖子类，而不必改变超类来定义所提出算法的框架。

![Design Patterns C#](../Images/75a0a0286b7592f7f4510ff820fa0278.png)

它只是将那些根据分配给它的算法进行操作的对象分开。

## 摘要

设计模式在决定那些在每一步都需要**最终效率**和**进步**的问题的解决方案中起着至关重要的作用。它们不仅仅局限于解决与定期发生的某个级别的问题相关的问题，而且还帮助开发人员像计算机一样思考以及如何处理问题。

在本教程中，我们看到了这些模式的动态性，并根据不同的场景来扩展它们。我们也清楚地知道这些模式到底是什么，从讨论的三种模式的不同子类别中找出。然而，对于开发人员来说，还有另一个难题，那就是事情会变得不可收拾，设计模式会出手相助。因此，可以用一句简短的话来总结，设计模式是智能且高效的代码片段，可用于 C#中数百万个常见问题。沉迷于 C#的开发人员总是意识到设计模式的重要性，因为 C#是一种动态编程语言，需要这些基于解决方案的模式的大量支持来处理日常问题。

* * ***